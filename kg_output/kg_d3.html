<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<title>Knowledge Graphs for Sustainable Aviation Fuel</title>
<style>

/* æ–°å¢ï¼šå¯†ç éªŒè¯ç•Œé¢æ ·å¼ */
#password-protection {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: linear-gradient(135deg, #ffffff 0%, #ffffff 100%);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
  font-family: Arial, sans-serif;
}

.password-container {
  background: rgba(255, 255, 255, 0.95);
  padding: 40px;
  border-radius: 15px;
  box-shadow: 0 10px 30px rgba(255, 255, 255, 0.3);
  text-align: center;
  width: 350px;
  max-width: 90%;
}  


  html,body { 
    height:100%; 
    margin:0; 
    font-family: Arial, sans-serif;
    overflow: hidden;
  }
  #controls {
    position:absolute;
    top:10px;
    left:10px;
    background:rgba(255,255,255,0.95);
    border:1px solid #ccc;
    padding:12px;
    border-radius:8px;
    font-size:12px;
    max-height:90%;
    overflow:auto;
    z-index:10;
    width:350px;
    box-shadow: 0 2px 10px rgba(255, 255, 255, 0.1);
  }
  #graph-container {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: #ffffff;
  }
  .filter-section { 
    margin-bottom: 12px;
    padding: 10px;
    background: #f9f9f9;
    border-radius: 5px;
  }
  .filter-section h4 { 
    margin:0 0 8px 0; 
    color: #333;
    font-size: 14px;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  
  /* å¯ç‚¹å‡»çš„åˆ†ç±»æ ‡ç­¾æ ·å¼ */
  .category-tag {
    display: inline-block;
    background: #e0e0e0;
    padding: 4px 10px;
    margin: 3px;
    border-radius: 15px;
    font-size: 11px;
    font-weight: bold;
    color: #555;
    cursor: pointer;
    transition: all 0.3s;
    border: 2px solid transparent;
  }
  
  .category-tag:hover {
    background: #d0d0d0;
    transform: translateY(-1px);
  }
  
  .category-tag.selected {
    background: #4CAF50;
    color: white;
    border-color: #388E3C;
  }
  
  /* å¯è°ƒæ•´å¤§å°çš„é€‰é¡¹å®¹å™¨ */
  .options-container {
    min-height: 100px;
    max-height: 250px;
    height: 200px; /* é»˜è®¤é«˜åº¦ */
    overflow-y: auto;
    border: 1px solid #ddd;
    border-radius: 4px;
    padding: 5px;
    background: white;
    margin: 8px 0;
   /* resize: vertical; /* å…è®¸å‚ç›´è°ƒæ•´å¤§å° */
    cursor: ns-resize;
  }
  
  .option-item {
    padding: 6px;
    margin: 3px 0;
    font-size: 12px;
    border-bottom: 1px solid #f0f0f0;
    transition: background-color 0.2s;
  }
  
  .option-item:hover {
    background-color: #f5f5f5;
  }
  
  .option-item:last-child {
    border-bottom: none;
  }
  
  .option-item label {
    cursor: pointer;
    display: flex;
    align-items: center;
  }
  
  .option-item input[type="checkbox"] {
    margin-right: 8px;
    transform: scale(1.1);
  }
  
  /* ä¸‹æ‹‰é€‰æ‹©æ¡†ä¹Ÿæ”¹ä¸ºå¯è°ƒæ•´å¤§å° */
  .filter-select {
    width: 100%;
    padding: 8px;
    border: 1px solid #ddd;
    border-radius: 4px;
    background: white;
    font-size: 12px;
   /* resize: vertical; */
    min-height: 100px;
    height: 120px;
  }
  
  .button-group {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 8px;
    margin: 15px 0;
  }
  button {
    padding: 10px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 13px;
    font-weight: bold;
    transition: all 0.3s;
  }
  button:hover {
    transform: translateY(-1px);
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
  }
  #search-btn { background: #4CAF50; color: white; }
  #reset-btn { background: #f44336; color: white; }
  #center-btn { background: #2196F3; color: white; }
  .select-all-none {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 5px;
    margin: 8px 0;
  }
  .select-all-none button { 
    background: #666; 
    color: white;
    padding: 6px;
    font-size: 11px;
  }
  .selected-count {
    font-size: 12px;
    color: #666;
    background: #eee;
    padding: 2px 6px;
    border-radius: 10px;
  }
  #loading {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: white;
    font-size: 18px;
    z-index: 100;
  }
  .error-message {
    position: absolute;
    top: 10px;
    right: 10px;
    background: rgba(255,0,0,0.8);
    color: white;
    padding: 10px;
    border-radius: 5px;
    z-index: 100;
    max-width: 300px;
  }
  
  /* èŠ‚ç‚¹é€‰æ‹©æ ·å¼ */
  .node-selected {
    border: 2px solid yellow;
    box-shadow: 0 0 10px yellow;
  }
  
  /* ç­›é€‰å™¨çŠ¶æ€æŒ‡ç¤º */
  .filter-status {
    font-size: 10px;
    color: #666;
    font-style: italic;
    margin-top: 5px;
  }
  
  /* åˆ†ç±»æ ‡ç­¾å®¹å™¨ */
  .category-tags-container {
    margin: 8px 0;
    padding: 8px;
    background: #f8f8f8;
    border-radius: 4px;
    border-left: 3px solid #4CAF50;
  }
</style>
</head>
<body>

<!-- æ–°å¢ï¼šå¯†ç éªŒè¯ç•Œé¢ -->
<div id="password-protection" style="
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: linear-gradient(135deg, #ffffff 0%, #ffffff 100%);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
  font-family: Arial, sans-serif;
">
  <div style="
    background: rgba(255, 255, 255, 0.95);
    padding: 40px;
    border-radius: 15px;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    text-align: center;
    width: 350px;
    max-width: 90%;
  ">
    <h2 style="color: #333; margin-bottom: 10px;">ğŸ”’ Access restricted</h2>
    <p style="color: #666; margin-bottom: 25px; font-size: 14px;">
      Please enter a password to access the Knowledge Graphs for Sustainable Aviation Fuel
    </p>
    <input 
      type="password" 
      id="password-input" 
      placeholder="Enter access password" 
      style="
        width: 100%;
        padding: 12px;
        border: 2px solid #ddd;
        border-radius: 8px;
        font-size: 16px;
        margin-bottom: 20px;
        box-sizing: border-box;
        transition: border-color 0.3s;
      "
      onkeypress="if(event.key === 'Enter') verifyPassword()"
    >
    <button 
      onclick="verifyPassword()" 
      style="
        width: 100%;
        padding: 12px;
        background: #4CAF50;
        color: white;
        border: none;
        border-radius: 8px;
        font-size: 16px;
        font-weight: bold;
        cursor: pointer;
        transition: background 0.3s;
      "
      onmouseover="this.style.background='#45a049'"
      onmouseout="this.style.background='#4CAF50'"
    >
      Verify password
    </button>
    <p id="error-message" style="color: #f44336; margin-top: 15px; font-size: 13px; display: none;">
      Incorrect password. Please try again.
    </p>
  </div>
</div>



<div id="controls">
  <h3 style="text-align: center; margin-bottom: 20px; color: #333;">Knowledge Graphs for Sustainable Aviation Fuel</h3>
  <div id="filters-container"></div>
  <div class="button-group">
    <button id="search-btn">ğŸ” Search Nodes</button>
    <button id="reset-btn">ğŸ”„ Reset All</button>
    <button id="center-btn">ğŸ¯ Center View</button>
  </div>
</div>
<div id="loading">Loading Graph...</div>
<div id="graph-container"></div>

<!-- å¼•å…¥å¿…è¦çš„åº“ -->
<script src="https://unpkg.com/three@0.150.1/build/three.min.js"></script>
<script src="https://unpkg.com/3d-force-graph@1.70.12/dist/3d-force-graph.min.js"></script>

<!-- åœ¨æ¨¡å—è„šæœ¬ä¹‹å‰æ·»åŠ æ™®é€šè„šæœ¬ -->
<script>
// æ–°å¢ï¼šå¯†ç éªŒè¯åŠŸèƒ½
const CORRECT_PASSWORD = "saf2025"; // è®¾ç½®æ‚¨çš„å¯†ç 

function verifyPassword() {
  const passwordInput = document.getElementById('password-input');
  const errorMessage = document.getElementById('error-message');
  const passwordProtection = document.getElementById('password-protection');
  
  if (passwordInput.value === CORRECT_PASSWORD) {
    // å¯†ç æ­£ç¡®ï¼Œéšè—éªŒè¯ç•Œé¢ï¼Œæ˜¾ç¤ºä¸»å†…å®¹
    passwordProtection.style.display = 'none';
    document.getElementById('controls').style.display = 'block';
    document.getElementById('graph-container').style.display = 'block';
    document.getElementById('loading').style.display = 'block';
    
    // å­˜å‚¨éªŒè¯çŠ¶æ€
    sessionStorage.setItem('passwordVerified', 'true');
    
    // é‡æ–°åŠ è½½é¡µé¢ä»¥ç¡®ä¿å›¾è°±æ­£ç¡®åˆå§‹åŒ–
    window.location.reload();
  } else {
    // å¯†ç é”™è¯¯
    errorMessage.style.display = 'block';
    passwordInput.style.borderColor = '#f44336';
    passwordInput.value = '';
    passwordInput.focus();
    
    // 3ç§’åéšè—é”™è¯¯ä¿¡æ¯
    setTimeout(() => {
      errorMessage.style.display = 'none';
      passwordInput.style.borderColor = '#ddd';
    }, 3000);
  }
}

// æ£€æŸ¥æ˜¯å¦å·²ç»éªŒè¯è¿‡ï¼ˆåˆ·æ–°é¡µé¢æ—¶ï¼‰
document.addEventListener('DOMContentLoaded', function() {
  const isVerified = sessionStorage.getItem('passwordVerified') === 'true';
  const passwordProtection = document.getElementById('password-protection');
  const controls = document.getElementById('controls');
  const graphContainer = document.getElementById('graph-container');
  const loading = document.getElementById('loading');
  
  if (isVerified) {
    // å·²é€šè¿‡éªŒè¯ï¼Œæ˜¾ç¤ºä¸»å†…å®¹
    passwordProtection.style.display = 'none';
    controls.style.display = 'block';
    graphContainer.style.display = 'block';
    loading.style.display = 'block';
  } else {
    // æœªé€šè¿‡éªŒè¯ï¼Œæ˜¾ç¤ºå¯†ç ç•Œé¢
    passwordProtection.style.display = 'flex';
    controls.style.display = 'none';
    graphContainer.style.display = 'none';
    loading.style.display = 'none';
    
    // èšç„¦åˆ°å¯†ç è¾“å…¥æ¡†
    setTimeout(() => {
      const passwordInput = document.getElementById('password-input');
      if (passwordInput) passwordInput.focus();
    }, 100);
  }
});


</script>

<script type="module">
  // åŠ¨æ€å¯¼å…¥ three-spritetext
let SpriteText;

// å…ˆæ£€æŸ¥è®¤è¯çŠ¶æ€ï¼Œå†å†³å®šæ˜¯å¦åŠ è½½æ¨¡å—
if (sessionStorage.getItem('passwordVerified') === 'true') {
  import('https://esm.sh/three-spritetext').then(module => {
    SpriteText = module.default;
    // åˆå§‹åŒ–å›¾è°±
    initializeGraph();
  }).catch(error => {
    console.error('Failed to load three-spritetext:', error);
    // å¦‚æœåŠ è½½å¤±è´¥ï¼Œä½¿ç”¨å¤‡é€‰æ–¹æ¡ˆ
    initializeGraph();
  });
} else {
  // å¦‚æœæ²¡æœ‰é€šè¿‡éªŒè¯ï¼Œéšè—loading
  document.getElementById('loading').style.display = 'none';
}

function initializeGraph() {
  class KnowledgeGraph3D {
    constructor() {
      // æ£€æŸ¥è®¤è¯çŠ¶æ€
      this.isAuthenticated = sessionStorage.getItem('passwordVerified') === 'true';
      
      if (!this.isAuthenticated) {
        console.log('æœªé€šè¿‡å¯†ç éªŒè¯ï¼Œè·³è¿‡å›¾è°±åˆå§‹åŒ–');
        document.getElementById('loading').style.display = 'none';
        return;
      }
      
      // åŸæœ‰çš„åˆå§‹åŒ–ä»£ç 
      this.graph = null;
      this.nodes = [];
      this.links = [];
      this.categories = {};
      this.visibleNodes = new Set();
      this.visibleLinks = new Set();
      this.nodeColors = {};
      this.filterOrder = [];
      this.availableNodesByType = {};
      this.selectedNodes = new Set();
      this.currentlyHighlighted = new Set();
      this.currentFilterIndex = 0;
      this.selectedCategories = new Set();

      this.pinnedTooltip = null; // æ–°å¢ï¼šå›ºå®šçš„å·¥å…·æç¤ºèŠ‚ç‚¹
      this.isTooltipPinned = false; // æ–°å¢ï¼šå·¥å…·æç¤ºæ˜¯å¦å›ºå®š
      
      this.init();
    }

    async init() {
      if (!this.isAuthenticated) {
        console.log('åˆå§‹åŒ–ä¸­æ­¢ï¼šæœªé€šè¿‡èº«ä»½éªŒè¯');
        document.getElementById('loading').style.display = 'none';
        return;
      }
      
      try {
        await this.loadData();
        this.setupGraph();
        this.createCascadingFiltersWithCategories();
        this.setupEventListeners();
      } catch (error) {
        this.showError('åˆå§‹åŒ–å¤±è´¥: ' + error.message);
        console.error('åˆå§‹åŒ–é”™è¯¯:', error);
        document.getElementById('loading').style.display = 'none';
      }
    }

    async loadData() {
      // æ–°å¢ï¼šæ£€æŸ¥è®¤è¯çŠ¶æ€
      if (!this.isAuthenticated) {
        throw new Error('æœªé€šè¿‡èº«ä»½éªŒè¯ï¼Œæ— æ³•åŠ è½½æ•°æ®');
      }
      
      try {
        let data;
        try {
          const response = await fetch('graph.json');
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          data = await response.json();
          console.log('æˆåŠŸä» graph.json åŠ è½½æ•°æ®');
          
        } catch (error) {
          console.warn('æ— æ³•åŠ è½½ graph.json:', error.message);
          try {
            const [nodesResponse, linksResponse] = await Promise.all([
              fetch('nodes.json'),
              fetch('links.json')
            ]);
            
            if (nodesResponse.ok && linksResponse.ok) {
              const nodes = await nodesResponse.json();
              const links = await linksResponse.json();
              data = { nodes, links };
              console.log('æˆåŠŸä» nodes.json å’Œ links.json åŠ è½½æ•°æ®');
            } else {
              throw new Error('æ— æ³•åŠ è½½æ•°æ®æ–‡ä»¶');
            }
          } catch (secondError) {
            console.warn('ä¹Ÿæ— æ³•åŠ è½½åˆ†å¼€çš„JSONæ–‡ä»¶:', secondError.message);
            data = this.generateCompleteTestData();
            console.log('ä½¿ç”¨å®Œæ•´æµ‹è¯•æ•°æ®');
          }
        }
        
        this.nodes = data.nodes;
        this.links = data.links;
        
        try {
          const categoryResponse = await fetch('categories.json');
          this.categories = await categoryResponse.json();
          console.log('æˆåŠŸåŠ è½½categoryæ•°æ®');
        } catch (error) {
          console.log('æ— æ³•åŠ è½½categories.jsonï¼Œä»èŠ‚ç‚¹æ•°æ®ç”Ÿæˆcategoryä¿¡æ¯');
          this.generateCategoriesFromNodes();
        }
        
        this.validateData();

        this.graphData = {
        nodes: this.nodes.map(node => ({
        id: node.id,
        name: node.name,
       type: node.type,
       category: node.category,
       // æ·»åŠ è¿™ä¸¤è¡Œï¼Œå¤åˆ¶titleså’Œdoiså­—æ®µ
       titles: node.titles || [],
       dois: node.dois || [],
       val: 5,
        color: this.nodeColors[node.type] || '#888888'
     })),
     links: this.links.map(link => ({
    source: link.source,
    target: link.target,
    relation: link.relation || 'related'
      }))
    };
        
        this.setupNodeColors();
        this.setupFilterOrder();
        
      } catch (error) {
        console.error('åŠ è½½æ•°æ®é”™è¯¯:', error);
        throw error;
      }
    }

    // generateCategoriesFromNodes æ–¹æ³•ä¿æŒä¸å˜
    generateCategoriesFromNodes() {
      this.categories = {
        "Feedstock": { categories: [], items: {} },
        "Catalyst": { categories: [], items: {} },
        "Product": { categories: [], items: {} }
      };
      
      this.nodes.forEach(node => {
        if (node.type === "Feedstock" && node.category) {
          if (!this.categories.Feedstock.items[node.category]) {
            this.categories.Feedstock.categories.push(node.category);
            this.categories.Feedstock.items[node.category] = [];
          }
          this.categories.Feedstock.items[node.category].push(node.name);
        }
        if (node.type === "Catalyst" && node.category) {
          if (!this.categories.Catalyst.items[node.category]) {
            this.categories.Catalyst.categories.push(node.category);
            this.categories.Catalyst.items[node.category] = [];
          }
          this.categories.Catalyst.items[node.category].push(node.name);
        }
        if (node.type === "Product" && node.category) {
          if (!this.categories.Product.items[node.category]) {
            this.categories.Product.categories.push(node.category);
            this.categories.Product.items[node.category] = [];
          }
          this.categories.Product.items[node.category].push(node.name);
        }
      });
    }

      getSortFunction(type) {
        const sortRules = {
          'Year': (a, b) => {
            const numA = parseInt(a.name.match(/\d+/)?.[0]) || 0;
            const numB = parseInt(b.name.match(/\d+/)?.[0]) || 0;
            return numA - numB;
          },
          'Reaction temperature': (a, b) => {
            const numA = parseInt(a.name.match(/\d+/)?.[0]) || 0;
            const numB = parseInt(b.name.match(/\d+/)?.[0]) || 0;
            return numA - numB;
          },
          'Reaction pressure': (a, b) => {
            const numA = parseInt(a.name.match(/\d+/)?.[0]) || 0;
            const numB = parseInt(b.name.match(/\d+/)?.[0]) || 0;
            return numA - numB;
          },
          'Flow rate': (a, b) => {
            const numA = parseInt(a.name.match(/\d+/)?.[0]) || 0;
            const numB = parseInt(b.name.match(/\d+/)?.[0]) || 0;
            return numA - numB;
          },
          'Reaction time': (a, b) => {
            const numA = parseInt(a.name.match(/\d+/)?.[0]) || 0;
            const numB = parseInt(b.name.match(/\d+/)?.[0]) || 0;
            return numA - numB;
          },
          'Product yield': (a, b) => {
            const getYieldValue = (name) => {
              if (name.includes('>')) return parseInt(name.match(/\d+/)?.[0]) + 100;
              if (name.includes('-')) {
                const nums = name.match(/\d+/g);
                return nums ? parseInt(nums[0]) : 0;
              }
              return parseInt(name.match(/\d+/)?.[0]) || 0;
            };
            return getYieldValue(a.name) - getYieldValue(b.name);
          },
         'Conversion rate': (a, b) => {
        const getConversionValue = (name) => {
        if (name.includes('>')) return parseInt(name.match(/\d+/)?.[0]) + 100;
        if (name.includes('-')) {
        const nums = name.match(/\d+/g);
        return nums ? parseInt(nums[0]) : 0;
        }
        return parseInt(name.match(/\d+/)?.[0]) || 0;
        };
        return getConversionValue(a.name) - getConversionValue(b.name);
      },
          'Product selectivity': (a, b) => {
            const order = { 'High': 3, 'Medium': 2, 'Low': 1 };
            return (order[b.name] || 0) - (order[a.name] || 0);
          }
        };
        
        return sortRules[type] || ((a, b) => a.name.localeCompare(b.name));
      }

      setupFilterOrder() {
        const allTypes = [
          "Reaction mode",
          "Year",
          "Feedstock",
          "Catalyst",
          "Product",
          "Product selectivity",
          "Product yield",
          "Atmosphere", 
          "Reactant molar ratio",
          "Flow rate",
          "Reaction time",
          "Reaction temperature",
          "Reaction pressure", 
          "Solvent", 
          "Conversion rate",
          "Feedstock category",
          "Catalyst category",
          "Product category"
        ];
        
        const existingTypes = new Set(this.nodes.map(n => n.type));
        this.filterOrder = allTypes.filter(type => existingTypes.has(type));
        
        console.log('ç­›é€‰é¡ºåº:', this.filterOrder);
      }

      updateAvailableNodes() {
        this.filterOrder.forEach(type => {
          const nodesOfType = this.nodes.filter(n => n.type === type);
          const sortFunction = this.getSortFunction(type);
          const sortedNodes = nodesOfType.sort(sortFunction);
          this.availableNodesByType[type] = new Set(sortedNodes.map(n => n.id));
        });

        const selectedIds = this.getSelectedNodeIds();
        
        if (selectedIds.size > 0) {
          const connectedNodeIds = new Set();
          
          selectedIds.forEach(nodeId => {
            this.links.forEach(link => {
              if (link.source === nodeId) {
                connectedNodeIds.add(link.target);
              }
              if (link.target === nodeId) {
                connectedNodeIds.add(link.source);
              }
            });
          });

          let lastSelectedIndex = -1;
          for (let i = 0; i < this.filterOrder.length; i++) {
            const type = this.filterOrder[i];
            const hasSelection = Array.from(selectedIds).some(id => {
              const node = this.nodes.find(n => n.id === id);
              return node && node.type === type;
            });
            
            if (hasSelection) {
              lastSelectedIndex = i;
            }
          }
          
          this.currentFilterIndex = Math.max(0, lastSelectedIndex);

        

          
          for (let i = this.currentFilterIndex + 1; i < this.filterOrder.length; i++) {
            const type = this.filterOrder[i];
            const currentAvailable = this.availableNodesByType[type];
            const filteredAvailable = new Set();
            
            connectedNodeIds.forEach(nodeId => {
              const node = this.nodes.find(n => n.id === nodeId);
              if (node && node.type === type && currentAvailable.has(nodeId)) {
                filteredAvailable.add(nodeId);
              }
            });
            
            this.availableNodesByType[type] = filteredAvailable;
          }
        } else {
          this.currentFilterIndex = 0;
        }
        
        this.createCascadingFiltersWithCategories();
      }

      validateData() {
        this.nodes.forEach((node, index) => {
          if (node.id === undefined) {
            node.id = index;
          }
        });
        
        this.links = this.links.filter(link => {
          const sourceExists = this.nodes.some(node => node.id === link.source);
          const targetExists = this.nodes.some(node => node.id === link.target);
          return sourceExists && targetExists;
        });
      }

      generateCompleteTestData() {
        const nodes = [];
        const links = [];
        let id = 0;

        const typeExamples = {
          "Reaction mode": ["Hydrogenation", "Oxidation", "Cracking", "Polymerization", "Esterification"],
          "Year": ["2018", "2019", "2020", "2021", "2022", "2023", "2024"],
          "Feedstock": [
            {name: "Methane", category: "Gaseous"},
            {name: "Ethylene", category: "Gaseous"}, 
            {name: "Propane", category: "Gaseous"},
            {name: "Butane", category: "Liquid"},
            {name: "Benzene", category: "Liquid"},
            {name: "Toluene", category: "Liquid"}
          ],
          "Catalyst": [
            {name: "Ni Catalyst", category: "Metal"},
            {name: "Pd Catalyst", category: "Metal"},
            {name: "Pt Catalyst", category: "Metal"}, 
            {name: "Zeolite", category: "Mineral"},
            {name: "Enzyme", category: "Biological"},
            {name: "Acid Catalyst", category: "Chemical"}
          ],
          "Product": [
            {name: "Ethanol", category: "Alcohol"},
            {name: "Methanol", category: "Alcohol"}, 
            {name: "Propylene", category: "Olefin"},
            {name: "Butadiene", category: "Diene"},
            {name: "Styrene", category: "Aromatic"},
            {name: "Ethylene", category: "Olefin"}
          ],
          "Product selectivity": ["Low", "Medium", "High", ">90%", "80-90%", "70-80%"],
          "Product yield": ["50-60%", "60-70%", "70-80%", "80-90%", ">90%"],
          "Atmosphere": ["Air", "N2", "H2", "O2", "Argon", "Vacuum"],
          "Reactant molar ratio": ["1:1", "1:2", "1:3", "2:1", "3:1", "10:1"],
          "Flow rate": ["5 mL/min", "10 mL/min", "20 mL/min", "50 mL/min", "100 mL/min", "200 mL/min"],
          "Reaction time": ["30 min", "1 h", "2 h", "4 h", "8 h", "24 h"],
          "Reaction temperature": ["50Â°C", "100Â°C", "150Â°C", "200Â°C", "250Â°C", "300Â°C", "400Â°C", "500Â°C"],
          "Reaction pressure": ["0.5 atm", "1 atm", "5 atm", "10 atm", "20 atm", "50 atm", "100 atm"],
          "Solvent": ["Water", "Ethanol", "Methanol", "Acetone", "Hexane", "Toluene"],
          "Conversion rate": ["50-60%", "60-70%", "70-80%", "80-90%", ">90%"]
        };

        Object.entries(typeExamples).forEach(([type, examples]) => {
          examples.forEach(example => {
            if (typeof example === 'object') {
              nodes.push({ 
                id: id++, 
                name: example.name, 
                type: type,
                category: example.category 
              });
            } else {
              nodes.push({ id: id++, name: example, type: type });
            }
          });
        });

        const reactionTypeNodes = nodes.filter(n => n.type === "Reaction mode");
        
        reactionTypeNodes.forEach(reactionNode => {
          const reactionName = reactionNode.name.toLowerCase();
          
          let years = ["2018", "2019", "2020"];
          let feedstocks = ["Methane", "Ethylene"];
          let catalysts = ["Ni Catalyst", "Pd Catalyst"];
          let products = ["Ethanol", "Methanol"];
          
          if (reactionName.includes("oxidation")) {
            years = ["2020", "2021", "2022"];
            feedstocks = ["Propane", "Butane"];
            catalysts = ["Pt Catalyst", "Zeolite"];
            products = ["Propylene", "Butadiene"];
          } else if (reactionName.includes("cracking")) {
            years = ["2019", "2020", "2021"];
            feedstocks = ["Benzene", "Toluene"];
            catalysts = ["Acid Catalyst", "Zeolite"];
            products = ["Styrene", "Ethylene"];
          }
          
          years.forEach(year => {
            const yearNode = nodes.find(n => n.type === "Year" && n.name === year);
            if (yearNode) links.push({ source: reactionNode.id, target: yearNode.id, relation: "has-year" });
          });
          
          feedstocks.forEach(feedstock => {
            const feedstockNode = nodes.find(n => n.type === "Feedstock" && n.name === feedstock);
            if (feedstockNode) links.push({ source: reactionNode.id, target: feedstockNode.id, relation: "has-feedstock" });
          });
          
          catalysts.forEach(catalyst => {
            const catalystNode = nodes.find(n => n.type === "Catalyst" && n.name === catalyst);
            if (catalystNode) links.push({ source: reactionNode.id, target: catalystNode.id, relation: "has-catalyst" });
          });
          
          products.forEach(product => {
            const productNode = nodes.find(n => n.type === "Product" && n.name === product);
            if (productNode) links.push({ source: reactionNode.id, target: productNode.id, relation: "has-product" });
          });
        });

        return { nodes, links };
      }

      setupNodeColors() {
        const typeColorMap = {
          'Reaction mode': '#ff4444',
          'Year': '#44ff44', 
          'Feedstock': '#1f77b4',
          'Feedstock category': '#1f77b4',
          'Catalyst': '#ff7f0e',
          'Catalyst category': '#ff7f0e',
          'Product': '#e377c2',
          'Product category': '#e377c2',
          'Product selectivity': '#2ca02c',
          'Product yield': '#8844ff',
          'Atmosphere': '#88ff44',
          'Reactant molar ratio': '#ff4488',
          'Flow rate': '#4488ff',
          'Reaction time': '#88ff88',
          'Reaction temperature': '#ff8888',
          'Reaction pressure': '#8888ff',
          'Solvent': '#ffff88',
          'Conversion rate': '#88ffff'
        };

        this.nodeColors = typeColorMap;
      }







  setupGraph() {
  document.getElementById('loading').style.display = 'none';
  
  if (this.nodes.length === 0) {
    this.showError('æ²¡æœ‰å¯ç”¨çš„æ•°æ®');
    return;
  }
  
  try {
    this.graph = ForceGraph3D()
      (document.getElementById('graph-container'))
      .width(window.innerWidth)
      .height(window.innerHeight)
      .graphData(this.graphData)
      .backgroundColor('#ffffff') // æ·»åŠ è¿™ä¸€è¡Œï¼Œè®¾ç½®èƒŒæ™¯è‰²ä¸ºç™½è‰²

      .nodeColor(node => this.nodeColors[node.type] || '#888888')
      .nodeRelSize(4)
      .nodeResolution(20)
      .nodeOpacity(0.9)
      
      .nodeThreeObject(node => {
        if (typeof SpriteText === 'undefined') {
          // å¦‚æœ SpriteText ä¸å¯ç”¨ï¼Œä½¿ç”¨é»˜è®¤çš„çƒä½“èŠ‚ç‚¹
          const nodeEl = new THREE.Mesh(
            new THREE.SphereGeometry(5),
            new THREE.MeshBasicMaterial({ 
              color: this.nodeColors[node.type] || '#888888',
              depthWrite: true
            })
          );
          return nodeEl;
        }

          // æ™ºèƒ½æ¢è¡Œå¤„ç†
  const processName = (name) => {
    const maxCharsPerLine = 18; // æ¯è¡Œæœ€å¤š18ä¸ªå­—ç¬¦
    
    if (name.length <= maxCharsPerLine) {
      return name;
    }
    
    const words = name.split(' ');
    let lines = [];
    let currentLine = '';
    
    for (let i = 0; i < words.length; i++) {
      const word = words[i];
      
      if (currentLine === '') {
        currentLine = word;
      } else if (currentLine.length + word.length + 1 <= maxCharsPerLine) {
        currentLine += ' ' + word;
      } else {
        lines.push(currentLine);
        currentLine = word;
      }
    }
    
    if (currentLine !== '') {
      lines.push(currentLine);
    }
    
    // é˜²æ­¢å•è¡Œè¿‡é•¿
    if (lines.length === 1 && lines[0].length > maxCharsPerLine) {
      const firstLine = lines[0].substring(0, maxCharsPerLine);
      const secondLine = lines[0].substring(maxCharsPerLine);
      lines = [firstLine, secondLine];
    }
    
    return lines.join('\n');
  };

  const displayName = processName(node.name);
  const sprite = new SpriteText(displayName);
  sprite.material.depthWrite = false;
  sprite.color = this.nodeColors[node.type] || '#888888';
  
  // æ‰€æœ‰æ ‡ç­¾å­—ä½“å¤§å°ä¸€è‡´
  sprite.textHeight = 10; // å›ºå®šå­—ä½“å¤§å°
  
  sprite.backgroundColor = 'transparent';
  sprite.backgroundOpacity = 0;
  sprite.padding = 3;
  sprite.borderRadius = 2;
  sprite.maxWidth = 90; // æ›´å®½çš„æ˜¾ç¤ºåŒºåŸŸ
  sprite.textAlign = 'center';
  
  // æ ¹æ®è¡Œæ•°è°ƒæ•´å‚ç›´ä½ç½®ï¼Œä½†å­—ä½“å¤§å°ä¸å˜
  const lineCount = displayName.split('\n').length;
  if (lineCount === 1) {
    sprite.position.y = 18;
  } else if (lineCount === 2) {
    sprite.position.y = 22;
  } else {
    sprite.position.y = 26;
  }
  
  return sprite;
})
      .nodeThreeObjectExtend(true)
      
      .nodeLabel(node => {
        const tooltipId = `tooltip-${node.id}`;
        
        return `
          <div style="background: rgba(0,0,0,0.95); color: white; padding: 12px; border-radius: 6px; font-size: 12px; max-width: 450px; border: 2px solid ${this.nodeColors[node.type] || '#888888'}">
            <strong style="font-size: 14px; color: ${this.nodeColors[node.type] || '#888888'}">${node.name}</strong><br/>
            <span style="color: #ccc">Type: ${node.type}</span>
            ${node.category ? `<br/><span style="color: #aaa">Category: ${node.category}</span>` : ''}
            
            ${node.titles && node.titles.length > 0 ? `
              <div style="margin-top: 8px;">
                <strong style="color: #ffcc00; display: block; margin-bottom: 4px;">ğŸ“š Related Literature</strong>
                <div id="${tooltipId}-titles">
                  ${node.titles.slice(0, 2).map(title => `
                    <div style="color: #ffdd99; margin: 2px 0; font-size: 11px;">â€¢ ${this.truncateText(title, 60)}</div>
                  `).join('')}
                  ${node.titles.length > 2 ? `
                    <div style="color: #ccc; cursor: pointer; font-size: 11px; margin-top: 4px;" 
                         onclick="kg.toggleMoreContent('${tooltipId}-titles', ${node.titles.length})">
                      ğŸ“– and ${node.titles.length - 2} more titles...
                    </div>
                  ` : ''}
                </div>
              </div>
            ` : ''}
            
            ${node.dois && node.dois.length > 0 ? `
              <div style="margin-top: 8px;">
                <strong style="color: #99ccff; display: block; margin-bottom: 4px;">ğŸ”— Related DOIs</strong>
                <div id="${tooltipId}-dois">
                  ${node.dois.slice(0, 2).map(doi => `
                    <div style="color: #99ccff; margin: 2px 0; font-size: 10px; font-family: monospace;">â€¢ ${this.truncateText(doi, 50)}</div>
                  `).join('')}
                  ${node.dois.length > 2 ? `
                    <div style="color: #ccc; cursor: pointer; font-size: 11px; margin-top: 4px;" 
                         onclick="kg.toggleMoreContent('${tooltipId}-dois', ${node.dois.length})">
                      ğŸ“„ and ${node.dois.length - 2} more DOIs...
                    </div>
                  ` : ''}
                </div>
              </div>
            ` : ''}
          </div>
        `;
      })
      
      // ä½¿ç”¨é“¾æ¥æ ‡ç­¾æ›¿ä»£ Three.js ç²¾çµæ–‡å­—
      .linkLabel(link => {
        const relationText = link.relation || 'related';
        return `
          <div style="background: transparent; color: #333; padding: 4px 8px; border-radius: 3px; font-size: 11px;">
            ${relationText}
          </div>
        `;
      })
      
      // å…¶ä»–é“¾æ¥é…ç½®
      .linkColor(() => 'rgba(80,80,80,0.8)') // æ”¹ä¸ºæ·±ç°è‰²
      .linkWidth(2.0) // å¢åŠ é“¾æ¥å®½åº¦
      .linkDirectionalParticles(2) // å¢åŠ ç²’å­æ•°é‡
      .linkDirectionalParticleSpeed(0.005) // å¢åŠ ç²’å­é€Ÿåº¦
      .linkDirectionalParticleWidth(1.5) // å¢åŠ ç²’å­å®½åº¦
      .onNodeHover(node => {

        // å¦‚æœæœ‰å›ºå®šå·¥å…·æç¤ºï¼Œä¸å¤„ç†æ‚¬åœäº‹ä»¶
        if (this.isTooltipPinned) {
        return;
        }


        if (node) {
          this.highlightRelatedNodes(node.id);
        } else {
          this.resetHighlight();
          this.resetTooltipContent();
        }
      })
      .onNodeClick(node => {
        // åˆ‡æ¢å›ºå®šå·¥å…·æç¤º
        this.togglePinnedTooltip(node);
        this.toggleNodeSelection(node);
      })

      // æ–°å¢ï¼šå³é”®æ‹–æ‹½å›ºå®šèŠ‚ç‚¹
      .onNodeDragEnd(node => {
        // å½“ç”¨æˆ·æ‹–æ‹½èŠ‚ç‚¹åï¼Œå›ºå®šèŠ‚ç‚¹ä½ç½®
        node.fx = node.x;
        node.fy = node.y;
        node.fz = node.z;
        console.log(`èŠ‚ç‚¹ "${node.name}" å·²è¢«å›ºå®šåœ¨ä½ç½® (${node.x.toFixed(2)}, ${node.y.toFixed(2)}, ${node.z.toFixed(2)})`);
      })
      
      // æ–°å¢ï¼šå³é”®ç‚¹å‡»é‡Šæ”¾èŠ‚ç‚¹
      .onNodeRightClick(node => {
        // é‡Šæ”¾èŠ‚ç‚¹
        node.fx = undefined;
        node.fy = undefined;
        node.fz = undefined;
        console.log(`èŠ‚ç‚¹ "${node.name}" å·²è¢«é‡Šæ”¾`);
// åˆ·æ–°å›¾è°±
        this.graph.refresh();
      });


    this.graph
      .d3Force('charge')
      .strength(-200)
      .distanceMax(1000);

    this.graph
      .d3Force('link')
      .distance(300)
      .strength(0.15);

    console.log('å›¾è°±åˆå§‹åŒ–å®Œæˆï¼ŒèŠ‚ç‚¹æ•°é‡:', this.nodes.length);

  } catch (error) {
    this.showError('3Då›¾å½¢åˆå§‹åŒ–å¤±è´¥: ' + error.message);
    console.error('å›¾å½¢åˆå§‹åŒ–é”™è¯¯:', error);
  }
}


// åœ¨è¿™é‡Œæ·»åŠ è¾…åŠ©æ–¹æ³•
truncateText(text, maxLength) {
  if (text.length <= maxLength) return text;
  return text.substring(0, maxLength) + '...';
}


// === æ–°å¢çš„å›ºå®šå·¥å…·æç¤ºæ–¹æ³• ===

// æ–°å¢ï¼šåˆ‡æ¢å›ºå®šå·¥å…·æç¤º
togglePinnedTooltip(node) {
  if (this.pinnedTooltip && this.pinnedTooltip.id === node.id) {
    // å¦‚æœç‚¹å‡»çš„æ˜¯å·²å›ºå®šçš„èŠ‚ç‚¹ï¼Œå–æ¶ˆå›ºå®š
    this.unpinTooltip();
  } else {
    // å›ºå®šæ–°çš„å·¥å…·æç¤º
    this.pinTooltip(node);
  }
}

// ä¿®æ”¹ï¼šå›ºå®šå·¥å…·æç¤º
pinTooltip(node) {
  this.pinnedTooltip = node;
  this.isTooltipPinned = true;
  
  // åˆ›å»ºå›ºå®šçš„å·¥å…·æç¤ºå…ƒç´ 
  this.createPinnedTooltipElement(node);
  
  // é«˜äº®ç›¸å…³èŠ‚ç‚¹
  this.highlightRelatedNodes(node.id);
}

// ä¿®æ”¹ï¼šå–æ¶ˆå›ºå®šå·¥å…·æç¤º
unpinTooltip() {
  this.pinnedTooltip = null;
  this.isTooltipPinned = false;
  
  // ç§»é™¤å›ºå®šçš„å·¥å…·æç¤ºå…ƒç´ 
  this.removePinnedTooltipElement();
  
  // é‡ç½®å›¾è°±çŠ¶æ€
  this.resetGraphState();
}


// æ–°å¢ï¼šé‡ç½®å›¾è°±çŠ¶æ€
resetGraphState() {
  if (this.graph) {
    // é‡ç½®æ‚¬åœçŠ¶æ€
    this.graph.onNodeHover(null);
    // é‡ç½®é«˜äº®
    this.resetHighlight();
    // é‡ç½®èŠ‚ç‚¹é¢œè‰²
    this.graph.nodeColor(node => this.nodeColors[node.type] || '#888888');
    // é‡ç½®é“¾æ¥é¢œè‰²
    this.graph.linkColor(() => 'rgba(200,200,200,0.6)');
  }
}


// æ–°å¢ï¼šåˆ›å»ºå›ºå®šçš„å·¥å…·æç¤ºå…ƒç´ 
createPinnedTooltipElement(node) {
  // å…ˆç§»é™¤å¯èƒ½å·²å­˜åœ¨çš„å›ºå®šå·¥å…·æç¤º
  this.removePinnedTooltipElement();
  
  // åˆ›å»ºå›ºå®šå·¥å…·æç¤ºå®¹å™¨
  const pinnedTooltip = document.createElement('div');
  pinnedTooltip.id = 'pinned-tooltip';
  pinnedTooltip.style.cssText = `
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0,0,0,0.95);
    color: white;
    padding: 15px;
    border-radius: 8px;
    font-size: 14px;
    max-width: 500px;
    max-height: 80vh;
    overflow-y: auto;
    border: 3px solid ${this.nodeColors[node.type] || '#888888'};
    z-index: 1000;
    box-shadow: 0 4px 20px rgba(0,0,0,0.5);
  `;
  
  // æ·»åŠ å…³é—­æŒ‰é’®
  pinnedTooltip.innerHTML = `
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
      <strong style="font-size: 16px; color: ${this.nodeColors[node.type] || '#888888'}">ğŸ“Œ Pinned: ${node.name}</strong>
      <button onclick="kg.unpinTooltip()" style="
        background: #f44336;
        color: white;
        border: none;
        border-radius: 4px;
        padding: 4px 8px;
        cursor: pointer;
        font-size: 12px;
      ">âœ• Close</button>
    </div>
    <div style="color: #ccc; margin-bottom: 8px;">Type: ${node.type}</div>
    ${node.category ? `<div style="color: #aaa; margin-bottom: 8px;">Category: ${node.category}</div>` : ''}
    
    ${node.titles && node.titles.length > 0 ? `
      <div style="margin-top: 12px;">
        <strong style="color: #ffcc00; display: block; margin-bottom: 6px;">ğŸ“š Related Literature</strong>
        <div>
          ${node.titles.map(title => `
            <div style="color: #ffdd99; margin: 4px 0; font-size: 12px; padding: 4px; background: rgba(255,204,0,0.1); border-radius: 3px;">â€¢ ${this.truncateText(title, 80)}</div>
          `).join('')}
        </div>
      </div>
    ` : ''}
    
    ${node.dois && node.dois.length > 0 ? `
      <div style="margin-top: 12px;">
        <strong style="color: #99ccff; display: block; margin-bottom: 6px;">ğŸ”— Related DOIs</strong>
        <div>
          ${node.dois.map(doi => `
            <div style="color: #99ccff; margin: 4px 0; font-size: 11px; font-family: monospace; padding: 4px; background: rgba(153,204,255,0.1); border-radius: 3px;">â€¢ ${this.truncateText(doi, 60)}</div>
          `).join('')}
        </div>
      </div>
    ` : ''}
  `;
  
  document.body.appendChild(pinnedTooltip);
}

// æ–°å¢ï¼šç§»é™¤å›ºå®šçš„å·¥å…·æç¤ºå…ƒç´ 
removePinnedTooltipElement() {
  const existingTooltip = document.getElementById('pinned-tooltip');
  if (existingTooltip) {
    existingTooltip.remove();
  }
}


// åˆ‡æ¢æ˜¾ç¤ºæ›´å¤šå†…å®¹
toggleMoreContent(elementId, totalCount) {
  const shortElement = document.getElementById(elementId);
  const fullElement = document.getElementById(elementId + '-full');
  const moreLink = shortElement.querySelector('div[onclick]');
  
  if (fullElement.style.display === 'none') {
    // æ˜¾ç¤ºå…¨éƒ¨å†…å®¹
    fullElement.style.display = 'block';
    moreLink.innerHTML = `ğŸ“• Show less`;
    moreLink.setAttribute('onclick', `kg.toggleMoreContent('${elementId}', ${totalCount})`);
  } else {
    // æ˜¾ç¤ºéƒ¨åˆ†å†…å®¹
    fullElement.style.display = 'none';
    moreLink.innerHTML = `ğŸ“– and ${totalCount - 2} more...`;
    moreLink.setAttribute('onclick', `kg.toggleMoreContent('${elementId}', ${totalCount})`);
  }
}

// ç‚¹å‡»èŠ‚ç‚¹å¤–éƒ¨æ—¶å…³é—­æ‰€æœ‰å±•å¼€çš„å†…å®¹
resetTooltipContent() {
    // å¦‚æœå·¥å…·æç¤ºæ˜¯å›ºå®šçš„ï¼Œä¸è¦é‡ç½®
  if (this.isTooltipPinned) {
    return;
  }
  


  // éšè—æ‰€æœ‰å±•å¼€çš„å†…å®¹
  document.querySelectorAll('[id$="-full"]').forEach(element => {
    element.style.display = 'none';
  });
  
  // é‡ç½®æ‰€æœ‰"and more"é“¾æ¥
  document.querySelectorAll('div[onclick*="toggleMoreContent"]').forEach(link => {
    const elementId = link.getAttribute('onclick').match(/'([^']+)'/)[1];
    const totalCount = parseInt(link.getAttribute('onclick').match(/(\d+)\)/)[1]);
    link.innerHTML = `ğŸ“– and ${totalCount - 2} more...`;
  });
}



      // æ–°å¢ï¼šç‚¹å‡»åˆ†ç±»æ ‡ç­¾é€‰æ‹©æ‰€æœ‰è¯¥åˆ†ç±»ä¸‹çš„é€‰é¡¹
      toggleCategorySelection(type, category) {
        const categoryKey = `${type}-${category}`;
        
        if (this.selectedCategories.has(categoryKey)) {
          // å–æ¶ˆé€‰æ‹©è¯¥åˆ†ç±»
          this.selectedCategories.delete(categoryKey);
          const items = this.categories[type].items[category] || [];
          items.forEach(item => {
            const nodeId = this.findNodeId(item, type);
            if (nodeId !== -1) {
              this.selectedNodes.delete(nodeId);
            }
          });
        } else {
          // é€‰æ‹©è¯¥åˆ†ç±»
          this.selectedCategories.add(categoryKey);
          const items = this.categories[type].items[category] || [];
          items.forEach(item => {
            const nodeId = this.findNodeId(item, type);
            if (nodeId !== -1 && this.availableNodesByType[type].has(nodeId)) {
              this.selectedNodes.add(nodeId);
            }
          });
        }
        
        this.updateFilterSelections();
        this.updateAvailableNodes();
      }

      // æ£€æŸ¥åˆ†ç±»æ˜¯å¦è¢«å®Œå…¨é€‰ä¸­
      isCategorySelected(type, category) {
        const items = this.categories[type].items[category] || [];
        const availableItems = items.filter(item => {
          const nodeId = this.findNodeId(item, type);
          return this.availableNodesByType[type].has(nodeId);
        });
        
        if (availableItems.length === 0) return false;
        
        return availableItems.every(item => {
          const nodeId = this.findNodeId(item, type);
          return this.selectedNodes.has(nodeId);
        });
      }

      toggleNodeSelection(node) {
        if (this.selectedNodes.has(node.id)) {
          this.selectedNodes.delete(node.id);
        } else {
          this.selectedNodes.add(node.id);
        }
        
        this.updateFilterSelections();
        this.updateAvailableNodes();
      }

      updateFilterSelections() {
        document.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
          const nodeId = parseInt(checkbox.value);
          checkbox.checked = this.selectedNodes.has(nodeId);
        });
        
        document.querySelectorAll('select.cascading-select').forEach(select => {
          Array.from(select.options).forEach(option => {
            const nodeId = parseInt(option.value);
            option.selected = this.selectedNodes.has(nodeId);
          });
        });
      }

      createCascadingFiltersWithCategories() {
        const container = document.getElementById('filters-container');
        container.innerHTML = '';
        
        if (this.nodes.length === 0) {
          container.innerHTML = '<p>æ²¡æœ‰å¯ç”¨çš„æ•°æ®</p>';
          return;
        }
        
        if (Object.keys(this.availableNodesByType).length === 0) {
          this.filterOrder.forEach(type => {
            const nodesOfType = this.nodes.filter(n => n.type === type);
            const sortFunction = this.getSortFunction(type);
            const sortedNodes = nodesOfType.sort(sortFunction);
            this.availableNodesByType[type] = new Set(sortedNodes.map(n => n.id));
          });
        }
        
        this.filterOrder.forEach((type, index) => {
          const section = document.createElement('div');
          section.className = 'filter-section';
          section.id = `filter-${type.replace(/\s+/g, '-')}`;
          
          if (['Feedstock', 'Catalyst', 'Product'].includes(type) && 
              this.categories[type] && this.categories[type].categories.length > 0) {
            section.innerHTML = this.createDirectCategorySection(type, index);
          } else {
            const nodesOfType = this.getAvailableNodesByType(type);
            section.innerHTML = this.createSimpleSection(type, nodesOfType, index);
          }
          
          container.appendChild(section);
        });
        
        this.updateAllSelectionCounts();
      }

      createDirectCategorySection(type, index) {
        const typeData = this.categories[type];
        const availableNodes = this.getAvailableNodesByType(type);
        const totalNodes = this.nodes.filter(n => n.type === type).length;
        
        let html = `
          <h4>
            ${type} 
            <span class="selected-count" id="count-${type.replace(/\s+/g, '-')}">0/${availableNodes.length} selected</span>
          </h4>
        `;
        
        if (index > this.currentFilterIndex && availableNodes.length < totalNodes) {
          html += `<div class="filter-status">Show related options (${availableNodes.length}/${totalNodes})</div>`;
        }
        
        // åˆ†ç±»æ ‡ç­¾åŒºåŸŸ
        html += `<div class="category-tags-container">`;
        typeData.categories.forEach(category => {
          const items = typeData.items[category] || [];
          const availableItems = items.filter(item => {
            const nodeId = this.findNodeId(item, type);
            return this.availableNodesByType[type].has(nodeId);
          });
          
          if (availableItems.length > 0) {
            const isSelected = this.isCategorySelected(type, category);
            html += `<span class="category-tag ${isSelected ? 'selected' : ''}" 
                     onclick="kg.toggleCategorySelection('${type}', '${category}')">${category}</span> `;
          }
        });
        html += `</div>`;
        
        // é€‰é¡¹å®¹å™¨ï¼ˆå¯è°ƒæ•´å¤§å°ï¼‰
        html += `<div class="options-container">`;
        
        typeData.categories.forEach(category => {
          const items = typeData.items[category] || [];
          const availableItems = items.filter(item => {
            const nodeId = this.findNodeId(item, type);
            return this.availableNodesByType[type].has(nodeId);
          });
          
          if (availableItems.length > 0) {
            availableItems.forEach(item => {
              const nodeId = this.findNodeId(item, type);
              const isSelected = this.selectedNodes.has(nodeId);
              html += `
                <div class="option-item">
                  <label>
                    <input type="checkbox" value="${nodeId}" data-type="${type}" 
                           ${isSelected ? 'checked' : ''}
                           onchange="kg.updateSelection()">
                    ${item}
                  </label>
                </div>
              `;
            });
          }
        });
        
        html += `</div>`;
        
        html += `
          <div class="select-all-none">
            <button onclick="kg.selectAllCategory('${type}')">Select All ${type}</button>
            <button onclick="kg.clearAllCategory('${type}')">Clear All ${type}</button>
          </div>
        `;
        
        return html;
      }

      createSimpleSection(type, nodesOfType, index) {
        const availableNodes = this.getAvailableNodesByType(type);
        const totalNodes = this.nodes.filter(n => n.type === type).length;
        
        let html = `
          <h4>
            ${type} 
            <span class="selected-count" id="count-${type.replace(/\s+/g, '-')}">0/${availableNodes.length} selected</span>
          </h4>
        `;
        
        if (index > this.currentFilterIndex && availableNodes.length < totalNodes) {
          html += `<div class="filter-status">Show related options (${availableNodes.length}/${totalNodes})</div>`;
        }
        
        html += `
          <select class="filter-select cascading-select" multiple data-type="${type}" data-index="${index}">
            ${availableNodes.map(n => {
              const isSelected = this.selectedNodes.has(n.id);
              return `<option value="${n.id}" ${isSelected ? 'selected' : ''}>${n.name}</option>`;
            }).join('')}
          </select>
          <div class="select-all-none">
            <button onclick="kg.selectAllType('${type}')">Select All</button>
            <button onclick="kg.clearAllType('${type}')">Clear All</button>
          </div>
        `;
        
        return html;
      }

      findNodeId(name, type) {
        const node = this.nodes.find(n => n.name === name && n.type === type);
        return node ? node.id : -1;
      }

      getAvailableNodesByType(type) {
        const availableNodeIds = this.availableNodesByType[type] || new Set();
        const nodesOfType = this.nodes.filter(node => 
          node.type === type && availableNodeIds.has(node.id)
        );
        const sortFunction = this.getSortFunction(type);
        return nodesOfType.sort(sortFunction);
      }

      updateSelection() {
        this.selectedNodes.clear();
        
        document.querySelectorAll('input[type="checkbox"]:checked').forEach(checkbox => {
          this.selectedNodes.add(parseInt(checkbox.value));
        });
        
        document.querySelectorAll('select.cascading-select').forEach(select => {
          Array.from(select.selectedOptions).forEach(option => {
            this.selectedNodes.add(parseInt(option.value));
          });
        });
        
        this.updateAvailableNodes();
      }

      selectAllCategory(type) {
        const typeData = this.categories[type];
        typeData.categories.forEach(category => {
          const items = typeData.items[category] || [];
          items.forEach(item => {
            const nodeId = this.findNodeId(item, type);
            if (nodeId !== -1 && this.availableNodesByType[type].has(nodeId)) {
              this.selectedNodes.add(nodeId);
            }
          });
        });
        this.updateFilterSelections();
        this.updateAvailableNodes();
      }

      clearAllCategory(type) {
        const typeData = this.categories[type];
        typeData.categories.forEach(category => {
          const items = typeData.items[category] || [];
          items.forEach(item => {
            const nodeId = this.findNodeId(item, type);
            if (nodeId !== -1) {
              this.selectedNodes.delete(nodeId);
            }
          });
        });
        this.updateFilterSelections();
        this.updateAvailableNodes();
      }

      selectAllType(type) {
        const select = document.querySelector(`select[data-type="${type}"]`);
        if (select) {
          Array.from(select.options).forEach(option => {
            this.selectedNodes.add(parseInt(option.value));
          });
          this.updateFilterSelections();
          this.updateAvailableNodes();
        }
      }

      clearAllType(type) {
        const select = document.querySelector(`select[data-type="${type}"]`);
        if (select) {
          Array.from(select.options).forEach(option => {
            this.selectedNodes.delete(parseInt(option.value));
          });
          this.updateFilterSelections();
          this.updateAvailableNodes();
        }
      }

      updateAllSelectionCounts() {
        this.filterOrder.forEach(type => {
          let count = 0;
          let total = 0;
          
          if (['Feedstock', 'Catalyst', 'Product'].includes(type)) {
            const typeData = this.categories[type];
            if (typeData) {
              typeData.categories.forEach(category => {
                const items = typeData.items[category] || [];
                items.forEach(item => {
                  const nodeId = this.findNodeId(item, type);
                  if (this.selectedNodes.has(nodeId) && this.availableNodesByType[type].has(nodeId)) {
                    count++;
                  }
                });
                total += items.filter(item => {
                  const nodeId = this.findNodeId(item, type);
                  return this.availableNodesByType[type].has(nodeId);
                }).length;
              });
            }
          } else {
            const select = document.querySelector(`select[data-type="${type}"]`);
            if (select) {
              count = Array.from(select.selectedOptions).length;
              total = select.options.length;
            }
          }
          
          const countElement = document.getElementById(`count-${type.replace(/\s+/g, '-')}`);
          if (countElement) {
            countElement.textContent = `${count}/${total} selected`;
          }
        });
      }

      getSelectedNodeIds() {
        return this.selectedNodes;
      }

      search() {
        const selectedIds = this.getSelectedNodeIds();
        
        if (selectedIds.size === 0) {
          alert('è¯·é€‰æ‹©è‡³å°‘ä¸€ä¸ªèŠ‚ç‚¹ï¼');
          return;
        }
        
        this.showSelectedNodes(selectedIds);
      }

      showSelectedNodes(selectedIds) {
        const visibleNodeIds = new Set(selectedIds);
        const visibleLinkIndices = new Set();
        
        selectedIds.forEach(nodeId => {
          this.links.forEach((link, index) => {
            if (link.source === nodeId || link.target === nodeId) {
              if (link.source === nodeId) visibleNodeIds.add(link.target);
              if (link.target === nodeId) visibleNodeIds.add(link.source);
              visibleLinkIndices.add(index);
            }
          });
        });
        
        const filteredData = {
          nodes: this.graphData.nodes.filter(node => visibleNodeIds.has(node.id)),
          links: this.graphData.links.filter((link, index) => visibleLinkIndices.has(index))
        };
        
        this.graph.graphData(filteredData);
        
        setTimeout(() => this.centerView(), 100);
      }

      showAllNodes() {
        this.graph.graphData(this.graphData);
        this.centerView();
      }

      reset() {
      this.selectedNodes.clear();
      this.selectedCategories.clear();
      this.availableNodesByType = {};
      this.currentFilterIndex = 0;
  
  // å–æ¶ˆå›ºå®šå·¥å…·æç¤º
  this.unpinTooltip();
        
        this.filterOrder.forEach(type => {
          const nodesOfType = this.nodes.filter(n => n.type === type);
          const sortFunction = this.getSortFunction(type);
          const sortedNodes = nodesOfType.sort(sortFunction);
          this.availableNodesByType[type] = new Set(sortedNodes.map(n => n.id));
        });
        
        this.createCascadingFiltersWithCategories();
        this.showAllNodes();

        // ç¡®ä¿å›¾è°±çŠ¶æ€å®Œå…¨é‡ç½®
        this.resetGraphState();
      }

      centerView() {
        this.graph.cameraPosition({ x: 0, y: 0, z: 400 });
      }

      highlightRelatedNodes(nodeId) {
        const relatedNodeIds = new Set([nodeId]);
        const relatedLinkIndices = new Set();
        
        this.links.forEach((link, index) => {
          if (link.source === nodeId || link.target === nodeId) {
            relatedNodeIds.add(link.source);
            relatedNodeIds.add(link.target);
            relatedLinkIndices.add(index);
          }
        });
        
        this.currentlyHighlighted = relatedNodeIds;
        
        this.graph
          .nodeColor(node => relatedNodeIds.has(node.id) 
            ? (this.nodeColors[node.type] || '#888888')
            : 'rgba(200,200,200,0.2)')
          .linkColor(() => 'rgba(200,200,200,0.6)');
      }

      resetHighlight() {
        this.currentlyHighlighted.clear();
        this.graph
          .nodeColor(node => this.nodeColors[node.type] || '#888888')
          .linkColor(() => 'rgba(200,200,200,0.6)');
      }

      focusOnNode(node) {
        const distance = 100;
        this.graph.cameraPosition(
          { x: node.x * 2, y: node.y * 2, z: node.z * 2 + distance },
          { x: node.x, y: node.y, z: node.z },
          1000
        );
      }

      showError(message) {
        const existingError = document.querySelector('.error-message');
        if (existingError) {
          existingError.remove();
        }
        
        const errorDiv = document.createElement('div');
        errorDiv.className = 'error-message';
        errorDiv.textContent = message;
        document.body.appendChild(errorDiv);
        
        setTimeout(() => {
          if (errorDiv.parentNode) {
            errorDiv.remove();
          }
        }, 5000);
      }

      setupEventListeners() {
        document.getElementById('search-btn').addEventListener('click', () => this.search());
        document.getElementById('reset-btn').addEventListener('click', () => this.reset());
        document.getElementById('center-btn').addEventListener('click', () => this.centerView());
        
        document.addEventListener('change', (event) => {
          if (event.target.classList.contains('cascading-select') || 
              event.target.type === 'checkbox') {
            this.updateSelection();
          }
        });
        
        window.addEventListener('resize', () => {
          if (this.graph) {
            this.graph.width(window.innerWidth).height(window.innerHeight);
          }
        });
      }
    }

    window.kg = new KnowledgeGraph3D();
  }
</script>
</body>
</html>